#depend "chem"
#depend "Box2dWeb-2.1.a.3" bare

const b2Vec2 = Box2D.Common.Math.b2Vec2
const b2BodyDef = Box2D.Dynamics.b2BodyDef
const b2Body = Box2D.Dynamics.b2Body
const b2FixtureDef = Box2D.Dynamics.b2FixtureDef
const b2World = Box2D.Dynamics.b2World
const {b2Shape, b2PolygonShape, b2CircleShape} = Box2D.Collision.Shapes

class Time
  (@world) ~>
    @speed = 0
    @body_definitions = []
    @history = []
    @color = [0,0,0]

  add_rectangle: !(x, y, half_width, half_height) ->
    body_definition = new b2BodyDef!
    body_definition.position.x = x
    body_definition.position.y = y
    fixture_definition = new b2FixtureDef!
    fixture_definition.density = 1.0
    fixture_definition.friction = 0.5
    fixture_definition.restitution = 0.2
    fixture_definition.shape = new b2PolygonShape!
    fixture_definition.shape.SetAsBox half_width, half_height
    @body_definitions.push {body_definition, fixture_definition}

  add_circle: !(x, y, radius) ->
    body_definition = new b2BodyDef!
    body_definition.position.x = x
    body_definition.position.y = y
    fixture_definition = new b2FixtureDef!
    fixture_definition.density = 1.0
    fixture_definition.friction = 0.5
    fixture_definition.restitution = 0.2
    fixture_definition.shape = new b2CircleShape radius
    @body_definitions.push {body_definition, fixture_definition}

  init: ->
    @create_bodies b2Body.b2_staticBody
    @store_history!
    @initial_frame = @history[0]

  create_bodies: !(type) ->
    for definition of @body_definitions
      @world.DestroyBody definition.body if definition.body?
      definition.body_definition.type = type
      definition.body = @world.CreateBody definition.body_definition
      definition.body.CreateFixture definition.fixture_definition

  speed_up: !->
    return if @speed >= 1
    @speed++
    if @speed is 1
      # get these suckers going
      @create_bodies b2Body.b2_dynamicBody
      @restore_from_history 1, @history[@history.length-1]
  slow_down: !->
    return if @speed <= -1
    @speed--
    if @speed is 0
      # turn these bodies into oblivious kinematics
      @create_bodies b2Body.b2_kinematicBody
      @restore_from_history 0, @history[@history.length-1]

  step: !->
    if @speed > 0
      @store_history!
    else if @speed < 0
      @restore_from_history -1, @history.pop!

  store_history: !->
    history_frame = []
    for definition of @body_definitions
      body = definition.body
      history_frame.push(
        position: body.GetPosition!.Copy!
        angle: body.GetAngle!
        velocity: body.GetLinearVelocity!.Copy!
        angular_velocity: body.GetAngularVelocity!
      )
    @history.push history_frame

  restore_from_history: !(velocity_scale, history_frame) ->
    history_frame ?= @initial_frame
    for state, i of history_frame
      @body_definitions[i].body.SetPositionAndAngle state.position, state.angle
      @body_definitions[i].body.SetLinearVelocity scale state.velocity, velocity_scale
      @body_definitions[i].body.SetAngularVelocity state.angular_velocity * velocity_scale

function scale(vector, scalar)
  answer = vector.Copy!
  answer.x *= scalar
  answer.y *= scalar
  answer

Chem.onReady ->
  const canvas = document.getElementById "game"
  const engine = new Chem.Engine canvas

  # GIMME THE FIZZAQS!
  world = null
  const min_dt = 1/60
  physics_per_second = 0
  times = []
  let
    gravity = new b2Vec2 0, 1
    world := new b2World gravity, true

    for i from 0 to 4
      times.push time = new Time world
      continue if i is 0
      for _ from 1 to 3
        Math.random!
        time.add_circle 2+Math.random!*18, 2+Math.random!*9, Math.random!*0.5+0.5

    # the ground
    times.0.add_rectangle 9, 13, 10, 0.5
    times.1.color = [0xff,0,0]
    times.2.color = [0,0xff,0]
    times.3.color = [0,0,0xff]
    times.4.color = [0xff,0xff,0]

    for time of times
      time.init!

  engine.on 'update', (real_dt, dx) ->
    for time, i of times
      # time 0 is the statics
      continue if i is 0
      if engine.buttonJustPressed Chem.Button["Key_#{i}"]
        if engine.buttonState Chem.Button.Key_Shift
          time.slow_down!
        else
          time.speed_up!

    # catch up the world to what we expect
    total_dt = 0
    while total_dt < real_dt
      world.Step min_dt, 1, 1
      for time of times
        time.step!
      world.ClearForces!
      total_dt += min_dt


  engine.on 'draw', (context) ->
    context.fillStyle = '#fff'
    context.clearRect 0, 0, engine.size.x, engine.size.y

    # if we apply the scale as a transformation, it will affect the width of strokes.
    scale = 32
    for time of times
      context.fillStyle = "rgba(#{time.color},0.5)"
      context.strokeStyle = "rgba(#{time.color},0.9)"
      for {body, fixture_definition} of time.body_definitions
        {shape} = fixture_definition
        switch shape.m_type
          case b2Shape.e_circleShape
            center = body.GetPosition!
            radius = shape.m_radius;
            angle = body.GetAngle!
            context.moveTo 0, 0
            context.beginPath!
            context.arc scale*center.x, scale*center.y, scale*radius, 0, Math.PI * 2, true
            context.moveTo scale*center.x, scale*center.y
            context.lineTo scale*(center.x + radius*Math.cos angle), scale*(center.y + radius*Math.sin angle)
            context.closePath!
            context.fill!
            context.stroke!
          case b2Shape.e_polygonShape
            center = body.GetPosition!
            vertexes = shape.GetVertices!.slice(0, shape.GetVertexCount!)
            v0 = vertexes.0
            context.beginPath!
            context.moveTo scale*(center.x+v0.x), scale*(center.y+v0.y)
            for v of vertexes
              context.lineTo scale*(center.x+v.x), scale*(center.y+v.y)
            context.lineTo scale*(center.x+v0.x), scale*(center.y+v0.y)
            context.closePath!
            context.fill!
            context.stroke!

    # draw a little fps counter in the corner
    context.fillStyle = '#000'
    engine.drawFps!

    # UI is on the right
    ui_width = 200
    ui_left = engine.size.x - ui_width
    bar_heith = 30
    bar_spacing = 10
    for time, i of times
      continue if i is 0
      top = i*(bar_heith + bar_spacing)
      # background
      context.fillStyle = "rgba(0,0,0,0.25)"
      context.fillRect ui_left, top, ui_width, bar_heith
      # history
      context.fillStyle = "rgba(#{time.color},0.5)"
      history_percent = time.history.length / 1000
      history_width = ui_width*history_percent
      context.fillRect ui_left, top, history_width, bar_heith
      # speed
      context.fillStyle = "rgba(#{time.color},0.9)"
      context.strokeStyle = '#000'
      context.beginPath!
      context.moveTo ui_left+history_width, top
      context.lineTo ui_left+history_width, top+bar_heith
      context.lineTo ui_left+history_width+time.speed*bar_heith/2, top+bar_heith/2
      context.lineTo ui_left+history_width, top
      context.closePath!
      context.fill!
      context.stroke!

  engine.start!
  canvas.focus!

clamp = (n, min, max) ->
  return min if n < min
  return max if n > max
  return n
